(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{171:function(e,t,n){"use strict";n.r(t);var o=n(0),i=Object(o.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),n("p",[e._v("As we have discussed several times, ISF is itself built on top of GLSL.  Whether you are already familiar with the language or just getting started, you may at times find it useful to adapt code from elsewhere to meet the ISF specification so that you can use the shaders between different softwares.  Likewise you may at times also find it useful to convert your ISF codebase into other formats to that have their own environment specific requirements for shaders.")]),e._v(" "),n("p",[e._v("In this chapter we'll look at:")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),n("p",[e._v("In many cases, GLSL code can be easily adapted to ISF by adding the JSON blob and making a few minor changes to a few function and variable names.")]),e._v(" "),e._m(3),e._v(" "),n("p",[e._v("Here is a list of tips that address many of the common differences:")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),n("p",[e._v("One of the most popular websites for learning GLSL is "),n("a",{attrs:{href:"https://thebookofshaders.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Book of Shaders"),n("OutboundLink")],1),e._v(", where you can find both a great explanation of how the language works and lots of sample code that show off all kinds of creative uses of shaders.")]),e._v(" "),n("p",[e._v("Here we will look at how to adapt one of the shaders from "),n("a",{attrs:{href:"https://thebookofshaders.com/12/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chapter 12: Cellular Noise"),n("OutboundLink")],1),e._v(" which covers a commonly used algorithm by Georgy Voronoi.  Similar to the Conway's Game of Life shader from the previous chapter,the voronoi algorithm simulates living forms that are shaped by this tension between an inner force to expand and grow, and limitations by outside forces.")]),e._v(" "),n("p",[e._v("You may want to read through the full explanation of voronoi from TBOS to get a full sense of what is happening in the shader, as in this tutorial we will simply look at how to adapt the code to work as in ISF.")]),e._v(" "),n("p",[e._v("Starting with this example:")]),e._v(" "),e._m(6),n("p",[e._v("Going through the list of suggested tips, the steps in which we will approach this will be:")]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),n("p",[e._v("The adapted result looks quite similar:")]),e._v(" "),e._m(10),n("p",[e._v("Of course this is just a basic adaptation.  Though they aren't needed, looking more closely at the code you may notice other minor changes that could be made, such as changing:")]),e._v(" "),e._m(11),n("p",[e._v("to the simpler form of:")]),e._v(" "),e._m(12),n("p",[e._v("As a challenge, take a few minutes to go through some of the other Cellular Noise examples from The Book of Shaders and convert them to work in ISF.")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"adapting-existing-glsl-code-to-the-isf-specification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adapting-existing-glsl-code-to-the-isf-specification","aria-hidden":"true"}},[this._v("#")]),this._v(" Adapting Existing GLSL Code to the ISF Specification")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("General tips for converting non-ISF GLSL shaders to ISF.")]),this._v(" "),t("li",[this._v("Adapting GLSL examples from The Book of Shaders.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"tips-for-converting-non-isf-glsl-shaders-to-isf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tips-for-converting-non-isf-glsl-shaders-to-isf","aria-hidden":"true"}},[this._v("#")]),this._v(" Tips for converting Non-ISF GLSL shaders to ISF")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("For example, if you are coming from an environment like Shader Toy or The Book of Shaders, the variable that they use for the time in seconds might be something like "),t("code",[this._v("u_time")]),this._v(" and you would simply need to change those to "),t("code",[this._v("TIME")]),this._v(" to work in ISF.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("You should probably replace any calls in your shader to "),n("code",[e._v("texture2D()")]),e._v(" or "),n("code",[e._v("texture2DRect()")]),e._v(" with "),n("code",[e._v("IMG_NORM_PIXEL()")]),e._v(" or "),n("code",[e._v("IMG_PIXEL()")]),e._v(", respectively. Images in ISF- inputs, persistent buffers, etc- can be accessed by either "),n("code",[e._v("IMG_NORM_PIXEL()")]),e._v(" or "),n("code",[e._v("IMG_PIXEL()")]),e._v(", depending on whether you want to use normalized or non-normalized coordinates to access the colors of the image. If your shader isn't using these- if it's using "),n("code",[e._v("texture2D()")]),e._v(" or "),n("code",[e._v("texture2DRect()")]),e._v("- it won't compile if the host application tries to send it a different type of texture.")]),e._v(" "),n("li",[e._v("If the shader you are converting makes use of any custom uniform variable declarations for receiving information from a host application, replace these with elements in the "),n("code",[e._v("INPUTS")]),e._v(" section of your JSON blob.")]),e._v(" "),n("li",[e._v("Many shaders pass in the resolution of the image being rendered (knowing where the fragment being evaluated is located within the output image is frequently useful). By default, ISF automatically declares a uniform vec2 named "),n("code",[e._v("RENDERSIZE")]),e._v(" which is passed the dimensions of the image being rendered.")]),e._v(" "),n("li",[e._v("If the shader you're converting requires a time value, note that the uniform float "),n("code",[e._v("TIME")]),e._v(" is declared, and passed the duration (in seconds) which the shader's been runing when the shader's rendered.")]),e._v(" "),n("li",[e._v("Many shaders don't use (or even acknowledge) the alpha channel of the image being rendered. There's nothing wrong with this- but when the shader's loaded in an application that uses the alpha channel, the output of the shader can look bizarre and unpredictable (though it usually involves something being darker than it should be). If you run into this, try setting gl_FragColor.a to 1.0 at the end of your shader.")]),e._v(" "),n("li",[n("code",[e._v("gl_FragCoord.xy")]),e._v(" contains the coordinates of the fragment being evaluated. "),n("code",[e._v("isf_FragNormCoord.xy")]),e._v(" contains the normalized coordinates of the fragment being evaluated.")]),e._v(" "),n("li",[e._v("While ISF files are fragment shaders, and the host environment automatically generates a vertex shader, you can use your own vertex shader if you'd like. If you go this route, your vertex shader should have the same base name as your ISF file (just use the extension .vs), and the first thing you do in your vertex shader's main function is call "),n("code",[e._v("isf_vertShaderInit();")]),e._v(".")]),e._v(" "),n("li",[e._v("If the shader you're converting requires imported graphic resources, note that the ISF format defines the ability to import image files by adding objects to your JSON dict under the "),n("code",[e._v("IMPORTED")]),e._v(" key. The imported images are accessed via the usual "),n("code",[e._v("IMG_PIXEL()")]),e._v(" or "),n("code",[e._v("IMG_NORM_PIXEL()")]),e._v(" methods. Details on how to do this are listed in the full specification and ISF Reference Pages.")]),e._v(" "),n("li",[e._v('If your texture doesn\'t look right, make sure your texture coordinates are ranged properly (textures are typically "clamped" by the host implementation, if you specify an out-of-range texture coordinate it may look funny).')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"adapting-glsl-examples-from-the-book-of-shaders"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adapting-glsl-examples-from-the-book-of-shaders","aria-hidden":"true"}},[this._v("#")]),this._v(" Adapting GLSL examples from The Book of Shaders.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("// Author: @patriciogv\n// Title: CellularNoise\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 3.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(u_time + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n    // color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n\n    gl_FragColor = vec4(color,1.0);\n}\n")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("Replace any automatically created variables with their respective ISF counterparts.")]),e._v(" "),n("li",[e._v("Remove any declarations of automatically created variables as this is handled automatically by ISF.")]),e._v(" "),n("li",[e._v("Add a JSON blob that describes the shader.")]),e._v(" "),n("li",[e._v("If needed replace instances of "),n("code",[e._v("texture2D")]),e._v(" / "),n("code",[e._v("texture2DRect")]),e._v(" with "),n("code",[e._v("IMG_PIXEL")]),e._v(".")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("In this case, first replace all cases of "),n("code",[e._v("u_time")]),e._v(" with "),n("code",[e._v("TIME")]),e._v(" and "),n("code",[e._v("u_resolution")]),e._v(" with "),n("code",[e._v("RENDERSIZE")]),e._v(".  Next remove their declarations.  In this case, the "),n("code",[e._v("u_mouse")]),e._v(" uniform is also not used in this code and can be removed.  This generator does not make use of any pixel lookup so there no need to change any related functions.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("When making adaptations it can also be useful to look in the code to find sections where you may want to add a custom uniform variable in the JSON blob.  In this example instead of the hardcoded value of 3.0 for the scaling, we have added a "),t("code",[this._v("scale")]),this._v(" element of type float to the "),t("code",[this._v("INPUTS")]),this._v(" array with a range of 0.0 to 8.0.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('/*{\n\t"DESCRIPTION": "Cellular Noise example",\n\t"CREDIT": "@patriciogv",\n\t"ISFVSN": "2",\n\t"CATEGORIES": [\n\t\t"TBOS"\n\t],\n\t"INPUTS": [\n\t\t{\n\t\t\t"NAME": "scale",\n\t\t\t"TYPE": "float",\n\t\t\t"MIN": 0.0,\n\t\t\t"MAX": 8.0,\n\t\t\t"DEFAULT": 3.0\n\t\t}\t\n\t]\t\n}*/\n\n// Author: @patriciogv\n// Title: CellularNoise\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/RENDERSIZE.xy;\n    st.x *= RENDERSIZE.x/RENDERSIZE.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= scale;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(TIME + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n    // color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n\n    gl_FragColor = vec4(color,1.0);\n}\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("vec2 st = gl_FragCoord.xy/RENDERSIZE.xy;\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("vec2 st = isf_FragNormCoord;\n")])])])}],!1,null,null,null);i.options.__file="primer_chapter_9.md";t.default=i.exports}}]);