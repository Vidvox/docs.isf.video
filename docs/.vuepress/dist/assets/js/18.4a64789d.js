(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{166:function(e,a,t){"use strict";t.r(a);var o=t(0),n=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"built-in-glsl-isf-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#built-in-glsl-isf-functions","aria-hidden":"true"}},[e._v("#")]),e._v(" Built-In GLSL / ISF Functions")]),e._v(" "),t("p",[e._v("The base language of GLSL includes many useful functions.  If you are writing shaders against the ISF specification there are a few additional functions that can be used for working with image data.")]),e._v(" "),t("h2",{attrs:{id:"isf-exclusive-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#isf-exclusive-functions","aria-hidden":"true"}},[e._v("#")]),e._v(" ISF Exclusive Functions")]),e._v(" "),t("p",[e._v("ISF extends GLSL with the following functions.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vec4 pixelColor = IMG_PIXEL(image imageName, vec2 pixelCoord); \nvec4 pixelColor = IMG_NORM_PIXEL(image imageName, vec2 normalizedPixelCoord);\nvec4 pixelColor = IMG_THIS_PIXEL(image imageName); \nvec4 pixelColor = IMG_NORM_THIS_PIXEL(image imageName); \nvec2 imageSize = IMG_SIZE(image imageName);\n")])])]),t("ul",[t("li",[t("code",[e._v("IMG_PIXEL()")]),e._v(" and "),t("code",[e._v("IMG_NORM_PIXEL()")]),e._v(" fetch the color of a pixel in an image using either pixel-based coords or normalized coords, respectively, and should be used "),t("em",[e._v("instead of")]),e._v(" "),t("code",[e._v("texture2D()")]),e._v(" or "),t("code",[e._v("texture2DRect()")]),e._v('. In both functions, "imageName" refers to the variable name of the image you want to work with.')]),e._v(" "),t("li",[t("code",[e._v("IMG_THIS_PIXEL()")]),e._v(" is essentially the same as "),t("code",[e._v("IMG_PIXEL()")]),e._v(" but automatically fills in the pixel coordinate for the pixel being rendered.")]),e._v(" "),t("li",[t("code",[e._v("IMG_NORM_THIS_PIXEL()")]),e._v(" is essentially the same as "),t("code",[e._v("IMG_THIS_PIXEL()")]),e._v(" but automatically fills in the pixel coordinate for the pixel being rendered using a normalized coordinate range.")]),e._v(" "),t("li",[t("code",[e._v("IMG_SIZE()")]),e._v(" returns a two-element vector describing the size of the image in pixels.")])]),e._v(" "),t("h2",{attrs:{id:"standard-glsl-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#standard-glsl-functions","aria-hidden":"true"}},[e._v("#")]),e._v(" Standard GLSL Functions")]),e._v(" "),t("p",[e._v("This is a reference for many of the commonly used built-in functions from the OpenGL Shading Language, aka GLSL.")]),e._v(" "),t("h3",{attrs:{id:"basic-number-operations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic-number-operations","aria-hidden":"true"}},[e._v("#")]),e._v(" Basic Number Operations")]),e._v(" "),t("p",[e._v("For each of these functions, you can use float input, or as vec2, vec3, or vec4 to perform the operations on multiple values at once. In most cases these functions take a single input parameter (x) and where specified take two parameters (x and y) For example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float abs(float x)  \nvec2 abs(vec2 x)  \nvec3 abs(vec3 x)  \nvec4 abs(vec4 x)\n")])])]),t("p",[e._v("or")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float mod(float x, float y)  \nvec2 mod(vec2 x, vec2 y)  \nvec3 mod(vec3 x, vec3 y)  \nvec4 mod(vec4 x, vec4 y)\n")])])]),t("ul",[t("li",[t("code",[e._v("pow")]),e._v(": The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x.")]),e._v(" "),t("li",[t("code",[e._v("sign")]),e._v(": The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative.")]),e._v(" "),t("li",[t("code",[e._v("floor")]),e._v(": The floor function returns the largest integer number that is smaller or equal to x. The return value is of type floating scalar or float vector although the result of the operation is an integer.")]),e._v(" "),t("li",[t("code",[e._v("ceil")]),e._v(": The ceiling function returns the smallest number that is larger or equal to x. The return value is of type floating scalar or float vector although the result of the operation is an integer.")]),e._v(" "),t("li",[t("code",[e._v("fract")]),e._v(": The fract function returns the fractional part of x, i.e. x minus floor(x).")]),e._v(" "),t("li",[t("code",[e._v("min")]),e._v(": The min function returns the smaller of the two arguments, x and y.")]),e._v(" "),t("li",[t("code",[e._v("max")]),e._v(": The max function returns the larger of the two arguments, x and y.")]),e._v(" "),t("li",[t("code",[e._v("mod")]),e._v(": The mod, short for Modulo, function returns x minus the product of y and floor(x/y).")])]),e._v(" "),t("p",[e._v("There are also a variations of the "),t("code",[e._v("min")]),e._v(", "),t("code",[e._v("max")]),e._v(" and "),t("code",[e._v("mod")]),e._v(" functions where the second parameter is always a floating scalar. For example,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float mod(float x, float y)  \nvec2 mod(vec2 x, float y)  \nvec3 mod(vec3 x, float y)  \nvec4 mod(vec4 x, float y)\n")])])]),t("h3",{attrs:{id:"angle-and-trigonometry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#angle-and-trigonometry","aria-hidden":"true"}},[e._v("#")]),e._v(" Angle and Trigonometry")]),e._v(" "),t("p",[e._v("For each of these functions, you can use float input, or as vec2, vec3, or vec4 to perform the operations on multiple values at once. For example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float radians(float degrees)  \nvec2 radians(vec2 degrees)  \nvec3 radians(vec3 degrees)  \nvec4 radians(vec4 degrees)\n")])])]),t("ul",[t("li",[t("code",[e._v("radians")]),e._v(": The radians function converts degrees to radians.")]),e._v(" "),t("li",[t("code",[e._v("degrees")]),e._v(": The degrees function converts radians to degrees.")]),e._v(" "),t("li",[t("code",[e._v("sin")]),e._v(": The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component.")]),e._v(" "),t("li",[t("code",[e._v("cos")]),e._v(": The cos function returns the cosine of an angle in radians.")]),e._v(" "),t("li",[t("code",[e._v("tan")]),e._v(": The tan function returns the tangent of an angle in radians")]),e._v(" "),t("li",[t("code",[e._v("asin")]),e._v(": The asin function returns the arcsine of an angle in radians. It is the inverse function of sine.")]),e._v(" "),t("li",[t("code",[e._v("acos")]),e._v(": The acos function returns the arccosine of an angle in radians. It is the inverse function of cosine.")]),e._v(" "),t("li",[t("code",[e._v("atan")]),e._v(": The atan function returns the arctangent of an angle in radians. It is the inverse function of tangent.")])]),e._v(" "),t("p",[e._v("There is also a two-argument variation of the atan function. For a point with Cartesian coordinates (x, y) the function returns the angle θ of the same point with polar coordinates (r, θ).")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float atan(float y, float x)  \nvec2 atan(vec2 y, vec2 x)  \nvec3 atan(vec3 y, vec3 x)  \nvec4 atan(vec4 y, vec4 x)\n")])])]),t("h3",{attrs:{id:"exponential"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exponential","aria-hidden":"true"}},[e._v("#")]),e._v(" Exponential")]),e._v(" "),t("p",[e._v("For each of these functions, you can use float input, or as vec2, vec3, or vec4 to perform the operations on multiple values at once. For example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float sqrt(float x)  \nvec2 sqrt(vec2 x)  \nvec3 sqrt(vec3 x)  \nvec4 sqrt(vec4 x)\n")])])]),t("p",[e._v("or")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float pow(float x, float y)  \nvec2 pow(vec2 x, vec2 y)  \nvec3 pow(vec3 x, vec3 y)  \nvec4 pow(vec4 x, vec4 y)\n")])])]),t("ul",[t("li",[t("code",[e._v("pow")]),e._v(": The power function returns x raised to the power of y.")]),e._v(" "),t("li",[t("code",[e._v("exp")]),e._v(": The exp function returns the constant e raised to the power of x.")]),e._v(" "),t("li",[t("code",[e._v("log")]),e._v(": The log function returns the power to which the constant e has to be raised to produce x, also known as the natural logarithm function.")]),e._v(" "),t("li",[t("code",[e._v("exp2")]),e._v(": The exp2 function returns 2 raised to the power of x.\nExponential function (base 2)")]),e._v(" "),t("li",[t("code",[e._v("log2")]),e._v(": The log2 function returns the power to which 2 has to be raised to produce x.")]),e._v(" "),t("li",[t("code",[e._v("sqrt")]),e._v(": The sqrt function returns the square root of x.")]),e._v(" "),t("li",[t("code",[e._v("inversesqrt")]),e._v(": The inversesqrt function returns the inverse square root of x, i.e. the reciprocal of the square root.")])]),e._v(" "),t("h3",{attrs:{id:"clamping-and-interpolation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clamping-and-interpolation","aria-hidden":"true"}},[e._v("#")]),e._v(" Clamping and Interpolation")]),e._v(" "),t("p",[e._v("GLSL provides several useful functions for clamping and interpolating between values.  Many of these functions can be used with a variety of different input parameter arrangements.")]),e._v(" "),t("p",[t("code",[e._v("clamp")]),e._v(": The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float clamp(float x, float minVal, float maxVal)  \nvec2 clamp(vec2 x, vec2 minVal, vec2 maxVal)  \nvec3 clamp(vec3 x, vec3 minVal, vec3 maxVal)  \nvec4 clamp(vec4 x, vec4 minVal, vec4 maxVal)\n")])])]),t("p",[e._v("There is also a variation of the "),t("code",[e._v("clamp")]),e._v(" function where the second and third parameters are always a floating scalars:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float clamp(float x, float minVal, float maxVal)  \nvec2 clamp(vec2 x, float minVal, float maxVal)  \nvec3 clamp(vec3 x, float minVal, float maxVal)  \nvec4 clamp(vec4 x, float minVal, float maxVal)\n")])])]),t("p",[t("code",[e._v("mix")]),e._v(": The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float mix(float x, float y, float a)  \nvec2 mix(vec2 x, vec2 y, vec2 a)  \nvec3 mix(vec3 x, vec3 y, vec3 a)  \nvec4 mix(vec4 x, vec4 y, vec4 a)\n")])])]),t("p",[e._v("There is also a variation of the "),t("code",[e._v("mix")]),e._v(" function where the third parameter is always a floating scalar.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float mix(float x, float y, float a)  \nvec2 mix(vec2 x, vec2 y, float a)  \nvec3 mix(vec3 x, vec3 y, float a)  \nvec4 mix(vec4 x, vec4 y, float a)\n")])])]),t("p",[t("code",[e._v("step")]),e._v(": The step function returns 0.0 if x is smaller then edge and otherwise 1.0.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float step(float edge, float x)  \nvec2 step(vec2 edge, vec2 x)  \nvec3 step(vec3 edge, vec3 x)  \nvec4 step(vec4 edge, vec4 x)\n")])])]),t("p",[e._v("There is also a variation of the step function where the edge parameter is always a floating scalar:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float step(float edge, float x)  \nvec2 step(float edge, vec2 x)  \nvec3 step(float edge, vec3 x)  \nvec4 step(float edge, vec4 x)\n")])])]),t("p",[t("code",[e._v("smoothstep")]),e._v(": The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomials.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float smoothstep(float edge0, float edge1, float x)  \nvec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x)  \nvec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x)  \nvec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x)\n")])])]),t("p",[e._v("There is also a variation of the smoothstep function where the edge0 and edge1 parameters are always floating scalars:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float smoothstep(float edge0, float edge1, float x)  \nvec2 smoothstep(float edge0, float edge1, vec2 x)  \nvec3 smoothstep(float edge0, float edge1, vec3 x)  \nvec4 smoothstep(float edge0, float edge1, vec4 x)\n")])])]),t("h3",{attrs:{id:"geometry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#geometry","aria-hidden":"true"}},[e._v("#")]),e._v(" Geometry")]),e._v(" "),t("p",[e._v("Unless otherwise specified these functions take the following form where applicable:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float length(float x)  \nfloat length(vec2 x)  \nfloat length(vec3 x)  \nfloat length(vec4 x)\n")])])]),t("p",[e._v("or")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float dot(float x, float y)  \nfloat dot(vec2 x, vec2 y)  \nfloat dot(vec3 x, vec3 y)  \nfloat dot(vec4 x, vec4 y)\n")])])]),t("ul",[t("li",[t("code",[e._v("length")]),e._v(": The length function returns the length of a vector defined by the Euclidean norm, i.e. the square root of the sum of the squared components.")]),e._v(" "),t("li",[t("code",[e._v("distance")]),e._v(": The distance function returns the distance between two points. The distance of two points is the length of the vector d = p0 - p1, that starts at p1 and points to p0.")]),e._v(" "),t("li",[t("code",[e._v("normalize")]),e._v(": The normalize function returns a vector with length 1.0 that is parallel to x, i.e. x divided by its length.")]),e._v(" "),t("li",[t("code",[e._v("dot")]),e._v(": The dot function returns the dot product of the two input parameters, i.e. the sum of the component-wise products. If x and y are the same the square root of the dot product is equivalent to the length of the vector.")]),e._v(" "),t("li",[t("code",[e._v("cross")]),e._v(": The cross function returns the cross product of the two input parameters, i.e. a vector that is perpendicular to the plane containing x and y and has a magnitude that is equal to the area of the parallelogram that x and y span.  The cross product is equivalent to the product of the length of the vectors times the sinus of the(smaller) angle between x and y.  The cross function will only take a pair of vec3 variables as input parameters and will always return a vec3 as a result."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vec3 cross(vec3 x, vec3 y)\n")])])])]),e._v(" "),t("li",[t("code",[e._v("faceforward")]),e._v(": The faceforward function returns a vector that points in the same direction as a reference vector. The function has three input parameters of the type floating scalar or float vector: N, the vector to orient, I, the incident vector, and Nref, the reference vector. If the dot product of I and Nref is smaller than zero the return value is N. Otherwise -N is returned."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float faceforward(float N, float I, float Nref)  \nvec2 faceforward(vec2 N, vec2 I, vec2 Nref)  \nvec3 faceforward(vec3 N, vec3 I, vec3 Nref)  \nvec4 faceforward(vec4 N, vec4 I, vec4 Nref)\n")])])])]),e._v(" "),t("li",[t("code",[e._v("reflect")]),e._v(": The reflect function returns a vector that points in the direction of reflection. The function has two input parameters of the type floating scalar or float vector: I, the incident vector, and N, the normal vector of the reflecting surface. Side note: To obtain the desired result the vector N has to be normalized."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float reflect(float I, float N)  \nvec2 reflect(vec2 I, vec2 N)  \nvec3 reflect(vec3 I, vec3 N)  \nvec4 reflect(vec4 I, vec4 N)\n")])])])]),e._v(" "),t("li",[t("code",[e._v("refract")]),e._v(": The refract function returns a vector that points in the direction of refraction.  The function has two input parameters of the type floating scalar or float vector and one input parameter of the type floating scalar: I, the incident vector, N, the normal vector of the refracting surface, and eta, the ratio of indices of refraction.  To obtain the desired result the vectors I and N have to be normalized."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("float refract(float I, float N, float eta)  \nvec2 refract(vec2 I, vec2 N, float eta)  \nvec3 refract(vec3 I, vec3 N, float eta)  \nvec4 refract(vec4 I, vec4 N, float eta)\n")])])])])]),e._v(" "),t("h3",{attrs:{id:"vector-logic-comparisons"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector-logic-comparisons","aria-hidden":"true"}},[e._v("#")]),e._v(" Vector Logic Comparisons")]),e._v(" "),t("p",[e._v("Unless otherwise specified, these functions all work on both floating and integer vector inputs these two forms:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("bvec2 lessThan(vec2 x, vec2 y)  \nbvec3 lessThan(vec3 x, vec3 y)    \nbvec4 lessThan(vec4 x, vec4 y)  \n")])])]),t("p",[e._v("and")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("bvec2 lessThan(ivec2 x, ivec2 y)  \nbvec3 lessThan(ivec3 x, ivec3 y)  \nbvec4 lessThan(ivec4 x, ivec4 y)\n")])])]),t("ul",[t("li",[t("code",[e._v("lessThan")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] < y[i].")]),e._v(" "),t("li",[t("code",[e._v("lessThanEqual")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] <= y[i].")]),e._v(" "),t("li",[t("code",[e._v("greaterThan")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] > y[i].")]),e._v(" "),t("li",[t("code",[e._v("greaterThanEqual")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] >= y[i].")]),e._v(" "),t("li",[t("code",[e._v("equal")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] == y[i].")]),e._v(" "),t("li",[t("code",[e._v("notEqual")]),e._v(": The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] != y[i].")]),e._v(" "),t("li",[t("code",[e._v("any")]),e._v(": The any function returns a boolean value as result of the evaluation whether any component of the input vector is TRUE."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("bool any(bvec2 x)  \nbool any(bvec3 x)  \nbool any(bvec4 x)\n")])])])]),e._v(" "),t("li",[t("code",[e._v("all")]),e._v(": The any function returns a boolean value as result of the evaluation whether all component of the input vector is TRUE."),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("bool all(bvec2 x)  \nbool all(bvec3 x)  \nbool all(bvec4 x)\n")])])])])])])}],!1,null,null,null);n.options.__file="ref_functions.md";a.default=n.exports}}]);