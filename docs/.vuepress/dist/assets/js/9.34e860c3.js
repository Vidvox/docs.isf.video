(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{176:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vertex-shaders"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertex-shaders","aria-hidden":"true"}},[e._v("#")]),e._v(" Vertex Shaders")]),e._v(" "),a("p",[e._v("When writing shaders that are designed for 2D images as the ISF specification is currently designed for, typically most of the code you'll write is in the fragment shader (.fs) of your ISF shader.  In all of the examples we've seen so far we haven't had to create a vertex shader at all - part of the ISF specification is to automatically generate one if there isn't one provided.")]),e._v(" "),a("p",[e._v("In this chapter we'll look at how to add a custom vertex shader to work alongside a fragment shader with ISF and one of the simple cases where they can be useful.  The specific topics covered will be:")]),e._v(" "),a("ul",[a("li",[e._v("What are vertex shaders and how are they different from fragment shaders?")]),e._v(" "),a("li",[e._v("How to include a vertex shader as part of an ISF composition.")]),e._v(" "),a("li",[e._v("How to pass information from a vertex shader to a fragment shader using varying variables.")]),e._v(" "),a("li",[e._v("A brief introduction to polar vs Cartesian coordinate spaces.")]),e._v(" "),a("li",[e._v("Using a vertex shader to create a basic rotation effect.")])]),e._v(" "),a("h2",{attrs:{id:"vertex-shaders-vs-fragment-shaders"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertex-shaders-vs-fragment-shaders","aria-hidden":"true"}},[e._v("#")]),e._v(" Vertex Shaders vs Fragment Shaders")]),e._v(" "),a("p",[e._v("Though ISF is designed to work with images, within OpenGL an image is a 2D plane, where this 2D plane itself has 4 coordinates (vertices) that make up its position in space and has pixels (fragments) on it.")]),e._v(" "),a("p",[e._v("The OpenGL Shading Language provides different types of shaders, vertex and fragment, for manipulating both the coordinate points and the pixels respectively.  If you are only looking to create or manipulate the pixels of an image, very often the fragment shader alone is enough because you want to draw using whatever 2D geometry is provided by the rendering pipeline that your generator or filter is running inside of.")]),e._v(" "),a("p",[e._v("However there are a few cases where it can be beneficial to include a custom vertex shader.  One such example that we will look at in this chapter is applying a rotation filter, which manipulates the coordinate points directly, moving the entire plane by adjusting the 4 vertex points instead of every single pixel.  Another use case that we will look at in the next chapter is using a vertex shader to precompute fragment coordinates for when performing convolutions.")]),e._v(" "),a("pre",[a("code",[e._v("Note: In GLSL there are even more kinds of shaders. Currently ISF is made for working with 2D images and only makes use of vertex and fragment shaders.  A draft version of the next version of the ISF specification introduces additional conventions for working with 3D shapes with vertex and geometry shaders.\n")])]),e._v(" "),a("h2",{attrs:{id:"using-vertex-shaders-in-isf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-vertex-shaders-in-isf","aria-hidden":"true"}},[e._v("#")]),e._v(" Using Vertex Shaders in ISF")]),e._v(" "),a("p",[e._v("When including a vertex shader as part of an ISF composition, start by creating a basic fragment shader that will include the JSON blob.  Then create another file with the same name but use a 'vs' file extension.  Whenever a host application tries to load the fragment shader, it will look to see if a custom matching .vs is included.  If not, the default vertex shader is used instead.")]),e._v(" "),a("p",[e._v("The most basic vertex shader for ISF would look something like this:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//\tpassthru.vs\n//\tput your code in the main() {} function\n\nvarying vec2 translated_coord;\n\nvoid main()\n{\n\t//\tmake sure to call this in your custom ISF shaders to perform initial setup!\n\tisf_vertShaderInit();\n\ttranslated_coord = isf_FragNormCoord;\n}\n")])])]),a("p",[e._v("And it match up with a corresponding boring passthru.fs that looks like this:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('//\tpassthru.fs\n/*{\n\t"DESCRIPTION": "Passes through each pixel",\n\t"CREDIT": "by VIDVOX",\n\t"ISFVSN": "2",\n\t"CATEGORIES": [\n\t\t"TEST-GLSL FX"\n\t],\n\t"INPUTS": [\n\t\t{\n\t\t\t"NAME": "inputImage",\n\t\t\t"TYPE": "image"\n\t\t}\n\t]\n}*/\n\nvarying vec2 translated_coord;\n\nvoid main() {\n\t//\tuses the translated_coord provided from the .vs\n\tgl_FragColor = IMG_NORM_PIXEL(inputImage,translated_coord);\n}\n')])])]),a("p",[e._v("This vertex shader isn't particularly exciting and is essentially what the default .vs looks like if you do not include a custom one.  Like the fragment shader, it just passes through whatever vertex information is passed into it.  The one important detail here is the "),a("code",[e._v("isf_vertShaderInit();")]),e._v(" which must be called to do the initial setup for the vertex shader.")]),e._v(" "),a("p",[e._v("The other noteworthy addition to this code is:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("varying vec2 translated_coord;\n")])])]),a("p",[e._v("Which is found in both the .vs and .fs files.  This is a special variable type know as "),a("code",[e._v("varying")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"varying-and-uniform-variables-in-vertex-shaders"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#varying-and-uniform-variables-in-vertex-shaders","aria-hidden":"true"}},[e._v("#")]),e._v(" Varying and Uniform Variables in Vertex Shaders")]),e._v(" "),a("p",[e._v("When including a custom vertex shaders, there are a few special kinds of variables that can be used to communicate between the different shaders.")]),e._v(" "),a("p",[e._v("We've already learned how "),a("code",[e._v("uniform")]),e._v(" variables are used to pass information from the host application into our shaders and in ISF these variables are defined as part of the JSON blob.  Any uniforms declared in the JSON blob are also automatically available to the fragment shader.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("varying")]),e._v(" variable type makes it possible to use the vertex shader to precompute values that are passed into the fragment shader, interpolating along the primitive in the process.  These")]),e._v(" "),a("pre",[a("code",[e._v('Note: Though the `varying` variable type is currently supported, future versions of GLSL have deprecated this idea.  As such it may get phased out in future versions of ISF.  However, most ISF hosts aim to be backwards compatible and this is exactly why the "ISFVSN" tag is included as an attribute in the JSON blob.\n')])]),e._v(" "),a("h2",{attrs:{id:"creating-a-rotation-filter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-rotation-filter","aria-hidden":"true"}},[e._v("#")]),e._v(" Creating a Rotation Filter")]),e._v(" "),a("p",[e._v("One of the practical use cases for working with vertex shaders in 2D space is creating a rotation filter.")]),e._v(" "),a("p",[e._v("In this section we'll write our rotation filter in two different ways, both essentially based on the same mathematical operations.  The first method will be written entirely in a fragment shader and the second will make use of the custom vertex shader.")]),e._v(" "),a("p",[e._v("This is also a great opportunity to talk a bit about with angles, trigonometry and polar coordinate spaces, which are extremely useful when writing shaders.")]),e._v(" "),a("h3",{attrs:{id:"angles-trigonometry-and-polar-coordinate-spaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#angles-trigonometry-and-polar-coordinate-spaces","aria-hidden":"true"}},[e._v("#")]),e._v(" Angles, Trigonometry and Polar Coordinate Spaces")]),e._v(" "),a("p",[e._v("So far when writing our shaders we've dealt exclusively with 2D points in the form of (x, y).  In some cases those values were normalized (ranged 0.0 to 1.0) and at other times they were ranged, going between 0.0 and and maximum value like the RENDERSIZE.")]),e._v(" "),a("p",[e._v("Another useful way to represent this information is in polar coordinates, where instead of (x, y) values, each point is represented by a distance and an angle (r, θ).  Once a coordinate is in the (r, θ) form, you can make adjustments to its position by adjusting the distance or angle, which is ideal for performing rotations, bump distortions and other visual effects that happen radially or in a circular fashion.")]),e._v(" "),a("p",[e._v("Converting to and from polar coordinates and traditional Cartesian coordinate spaces is easy, as you will see in the rotation filter code below.")]),e._v(" "),a("p",[e._v("GLSL provides many built-in functions for working with angles and trigonometry, a list of which can be found in the "),a("a",{attrs:{href:"ref_variables"}},[e._v("ISF and GLSL Variables and Uniforms Reference Page")]),e._v(" for quick lookup.")]),e._v(" "),a("h3",{attrs:{id:"rotation-in-a-fragment-shader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rotation-in-a-fragment-shader","aria-hidden":"true"}},[e._v("#")]),e._v(" Rotation in a Fragment Shader")]),e._v(" "),a("p",[e._v("If we were limited to working with a fragment shader, as some environments are, the following code is sufficient for rotating an image.")]),e._v(" "),a("p",[e._v("Here a rotation is performed by converting each point to polar coordinates, adding to the angle and then converting back to Cartesian for the look up from the original image.")]),e._v(" "),a("p",[e._v("This same math for going between coordinate spaces can be re-used in other situations.  Though not exactly the same, you may recall seeing similar looking code in Chapter 3 when we looked at the Twirl.fs filter.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('/*\n{\n  "CATEGORIES" : [\n    "Geometry Adjustment"\n  ],\n  "ISFVSN" : "2",\n  "INPUTS" : [\n    {\n      "NAME" : "inputImage",\n      "TYPE" : "image"\n    },\n    {\n      "NAME" : "angle",\n      "TYPE" : "float",\n      "MAX" : 1,\n      "DEFAULT" : 0,\n      "MIN" : 0\n    }\n  ],\n  "CREDIT" : "by VIDVOX"\n}\n*/\n\nconst float pi = 3.14159265359;\n\nvoid main()\t{\n\t//\t\'loc\' is the location in pixels of this vertex.  we\'re going to convert this to polar coordinates (radius/angle)\n\tvec2\t\tloc = IMG_SIZE(inputImage) * vec2(isf_FragNormCoord[0],isf_FragNormCoord[1]);\n\t//\t\'r\' is the radius- the distance in pixels from \'loc\' to the center of the rendering space\n\tfloat\t\tr = distance(IMG_SIZE(inputImage)/2.0, loc);\n\t//\t\'a\' is the angle of the line segment from the center to loc is rotated\n\tfloat\t\ta = atan ((loc.y-IMG_SIZE(inputImage).y/2.0),(loc.x-IMG_SIZE(inputImage).x/2.0));\n\t\n\t//\tnow modify \'a\', and convert the modified polar coords (radius/angle) back to cartesian coords (x/y pixels)\n\tloc.x = r * cos(a + 2.0 * pi * angle);\n\tloc.y = r * sin(a + 2.0 * pi * angle);\n\t\n\tloc = loc / IMG_SIZE(inputImage) + vec2(0.5);\n\tif ((loc.x < 0.0)||(loc.y < 0.0)||(loc.x > 1.0)||(loc.y > 1.0))\t{\n\t\tgl_FragColor = vec4(0.0);\n\t}\n\telse\t{\n\t\tgl_FragColor = IMG_NORM_PIXEL(inputImage,loc);\n\t}\n}\n')])])]),a("h3",{attrs:{id:"rotation-in-a-vertex-shader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rotation-in-a-vertex-shader","aria-hidden":"true"}},[e._v("#")]),e._v(" Rotation in a Vertex Shader")]),e._v(" "),a("p",[e._v("Now let's do the same thing, but instead of doing the translation in the fragment shader we'll use the vertex shader")]),e._v(" "),a("p",[e._v("Here is the code for Rotate.vs / Rotate.fs")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//\tRotate.vs\nvarying vec2 translated_coord;\n\nconst float pi = 3.14159265359;\n\nvoid main()\t{\n\tisf_vertShaderInit();\n\t\n\t//\t'loc' is the location in pixels of this vertex.  we're going to convert this to polar coordinates (radius/angle)\n\tvec2\t\tloc = IMG_SIZE(inputImage) * vec2(isf_FragNormCoord[0],isf_FragNormCoord[1]);\n\t//\t'r' is the radius- the distance in pixels from 'loc' to the center of the rendering space\n\tfloat\t\tr = distance(IMG_SIZE(inputImage)/2.0, loc);\n\t//\t'a' is the angle of the line segment from the center to loc is rotated\n\tfloat\t\ta = atan ((loc.y-IMG_SIZE(inputImage).y/2.0),(loc.x-IMG_SIZE(inputImage).x/2.0));\n\t\n\t//\tnow modify 'a', and convert the modified polar coords (radius/angle) back to cartesian coords (x/y pixels)\n\tloc.x = r * cos(a + 2.0 * pi * angle);\n\tloc.y = r * sin(a + 2.0 * pi * angle);\n\t\n\ttranslated_coord = loc / IMG_SIZE(inputImage) + vec2(0.5);\n}\n")])])]),a("p",[e._v("And the matching Rotate.fs:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('/*{\n\t"CREDIT": "by VIDVOX",\n\t"ISFVSN": "2",\n\t"CATEGORIES": [\n\t\t"Geometry Adjustment"\n\t],\n\t"INPUTS": [\n\t\t{\n\t\t\t"NAME": "inputImage",\n\t\t\t"TYPE": "image"\n\t\t},\n\t\t{\n\t\t\t"NAME": "angle",\n\t\t\t"TYPE": "float",\n\t\t\t"MIN": 0.0,\n\t\t\t"MAX": 1.0,\n\t\t\t"DEFAULT": 0.0\n\t\t}\n\t]\n}*/\n\n//\tRotate.fs\n\nvarying vec2 translated_coord;\n\nvoid main() {\n\tvec2 loc = translated_coord;\n\t//\tif out of range draw black\n\tif ((loc.x < 0.0)||(loc.y < 0.0)||(loc.x > 1.0)||(loc.y > 1.0))\t{\n\t\tgl_FragColor = vec4(0.0);\n\t}\n\telse\t{\n\t\tgl_FragColor = IMG_NORM_PIXEL(inputImage,loc);\n\t}\n}\n')])])]),a("p",[e._v("As you may note, the code here looks very much the same as in the previous example.  However because we've moved a lot of the computation over to the vertex shader, this version will run more efficiently.")]),e._v(" "),a("p",[e._v("The fragment shader here still does the small amount of work to make sure that the "),a("code",[e._v("translated_coord")]),e._v(" is within the readable range for the original image and if not returns transparent black instead.")]),e._v(" "),a("h2",{attrs:{id:"other-vertex-shader-use-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other-vertex-shader-use-cases","aria-hidden":"true"}},[e._v("#")]),e._v(" Other Vertex Shader Use Cases")]),e._v(" "),a("p",[e._v("Over the next few chapters we will see a handful of other examples where vertex shaders come into play, particularly with the concept of Convolution which we will investigate in the next chapter.")])])}],!1,null,null,null);r.options.__file="primer_chapter_5.md";t.default=r.exports}}]);